# The `$_` variable
The humble `$_` looks innocuous enough at first: It just represents the "current input line" (more on that later). However, it's actually one of the most interesting of all the globals:

The `$_` is probably the most unusual global of them all. Unique among builtin globals (with the notable exception of `$-d`/`$DEBUG`), it can be assigned _any_ value!

## Crash course + Perl Background
The `$_` variable represents the "current input" line. It comes directly from Perl, where `$_` was used heavily, and was the implicit value for functions that were given no argument:
```perl
# Read each line at a time from stdin, and place them in the `$_` variable
while (<>) {
	next unless /world/; # Require that `$_` contains `world`
	chomp;               # Delete trailing newline off `$_`
	s/hello/hola/;       # Replace `hello` with `hola` in `$_`
	print;               # Print out `$_`
}
```

This is wildly unreadable, especially if you're not familiar with Perl. You can, however, do all these operations with an explicit variable:
```perl
while ($line = <>) {
	next unless $line =~ /world/;
	chomp $line;
	$line =~ s/hello/hola/;
	print $line;
}
```

Ruby, being inspired by Perl, was originally designed with the implicit use of `$_` in mind, with a handful of builtin functions that support it. Rewriting the Perl example using `$_`:
```ruby
while gets                 # Read input line into `$_`
	next unless ~/world/    # Require `$_` to contain `world`
	$_.chomp!               # These have to be explicit normally. However, see...
	$_.sub! /hello/, 'hola' #  ... the later section about Kernel methods
	print                   # Print `$_` out
end
```

As you can see, pretty similar.

## Where is `$_` used?
Ok, now with the crash course, where exactly is `$_` even used? Well, by searching the source code exhaustively, there are three different ways that `$_` is used:

### `gets` (and `readline`)
The first place is in `gets` (and the related `readline`, which is identical to `gets` in all ways except it throws `EOFError` instead of returning `nil` at end-of-input). Whenever `gets()` is called, the very last thing that happens is `$_` is assigned to the return value.

Interestingly, this `$_` assignment is actually done for *every* `gets`/`readline` method in Ruby's standard library (`IO`, `ARGF`, and `Kernel`), and also related extension gems (like `StringIO` and `ZLib`):

### `IO.foreach`
The only other place in the stdlib (asides from flag-methods; see later!) that actually sets `$_` is the oft-unused `IO.foreach`: It sets it once for each line, and then to `nil` at the very end.

This seems pretty useless, `IO.foreach` passes in the read line into its block anyways:
```ruby
IO.foreach 'foo.txt' do |line|
	# in fact, `$_` and `line` are identical. This never aborts
	abort unless line.equal? $_
end
```

### `Kernel#print`
Directly taken from Perl, Ruby's `Kernel#print()`, when given no arguments, is identical to `Kernel#print($_)`:
```ruby
$_ = "hello"
print # same as `print($_)`
```

(As an aside, I assume this is part of the reason the `$\` variable exists—so that you can print newlines with `print()` without having to do `print($_, "\n")`)

### Regex `~`
The other method in the standard library reads from `$_` is `Regex#~`, i.e. done as `~/foo/`. This essentially a shorthand for `/foo/ =~ $_` with the following differences:
1. It ignores any redefinitions of `Regexp#=~` and uses whatever the original one was
2. It doesn't expand capture groups into local variables (`/(?<name>\w+)/ =~ "hi"; p name` doesn't work)
3. `$_` _must_ be a `String` (or a `String` subclass) otherwise it'll return `nil`. (The `Regexp#=~` method also accepts `Symbol`s, and any type that has a `to_str` defined on it)

I suspect this was done as a way to still allow for `foo if /x/` constructs but to deprecate regex literals in conditions. (See the later section)

### `Kernel` globals with `-n`: `sub`, `gsub`, `chomp`, and `chop`
To round off the list of methods that use `$_`is the Kernel methods `Kernel#{sub,gsub,chomp,chop}`. Unlike every other method in Ruby, these methods are *only* available if you invoked ruby with the `-n` flag.

These methods are identical to the `String` versions of them, except they're all destructive (ie they modify `$_`), and none of them ever return `nil`:
```ruby
# assume `-n`
$_ = "hello\n"
p sub(/e/, 'E')  #=> "hEllo\n"
p sub(/q/, '!')  #=> "hEllo\n"
p gsub(/l/, 'L') #=> "hELLo\n"
p chomp          #=> "hELLo"
p chop           #=> "hELLo"
```

Unlike most other `$_` methods, these actually requires `$_` to be `String`, not something that defines `to_str` (or even `nil`).

### `English`'s version
The `require "English"` module defines one alias for `$_`: `$LAST_READ_LINE`. Like every other `English` alias, I have literally never had a need for this, as I only really use shorthand global variables in throwaway scripts (where I know what I'm doing). For longer scripts, I'll just do `line = gets` and avoid `$_` entirely.

## Regex literals in conditions (`... if /foo/`)
Oh boy this is a fun one. One of those "Perlisms" that Ruby's slowly trying to move away from, using a regex literal in a conditional will yell compiler warnings at you unless you pass `-W0` (to disable all warnings) or are passing scripts via `-e`:

```ruby
# warning: regex literal in condition
... if /foo/

# you can use `~` to avoid the warning; totally ok!
... if ~/foo/
```

It's not limited to `if` either `while`, `until` and `unless` also all work:
```ruby
... until /hello/
while /world/; ... end
... unless /yay/
```

However, it can _only_ be used as the sole condition in `if`/`elsif`/`unless`/`while`/`until` statements. Notably, it doesn't work with `and`/`or`, `&&`/`||`.

It is functionally identical to `/foo/ =~ $_`, except it won't expand captured groups in the regex for local variables. However, unlike `Regexp#~`, you *can* redefine `Regexp#=~` and actually change the functionality of regex literals in conditionals. This lets you have three "truthiness"es in ruby: Truthy, falsey, and regexp-y!

```ruby
class Regexp
  def =~(_ignored) = rand < 0.5
end

... if /foo/ # only works half the time!
```

Honestly, I only ever use this in quick oneliners on the command line, usually when I'm doing `-n`: `ruby -n -e 'print if /.../'`.

## Flags that interact with `$_`
__END__
<TODO>
When you pass the `-n` flag to your Ruby program, in addition to adding an implicit `while gets; ... end`


print if

But what about `-a`


- `Kernel#print`: When called without

_functions_ that use `$_`

- `Kernel#print`, if called with no arguments, is the same as `Kernel#print($_)`
- `Regexp#~` is a unary operator that is the same as `regex =~ $_`, with the exception that `$_` _must_ be a `String` (or a `String` subclass), or it'll return `nil`. (The `Regexp#=~` method also accepts `Symbol`s, and any type that has a `to_str` defined on it)
- External gem `Zlib::GzipReader#gets` & `readline` assigns it
- `IO#foreach`
- `ARGF#{gets,readline}`
- `IO#{gets,readline}`
- `StringIO#{gets,readline}`

## `Kernel` globals with `-p`: `sub`, `gsub`, `chomp`, `chop`
(all require `String` or its subclass)

# `$_` being a local variable
# flags and how they interact with it

# Abusing regexes in conditionals (`... if /../`)
`... if /regex/` is identical to `/regex/ =~ $_`, except "captured variables in regex are locals" isnt performed

# `alias`ing `$_`


rb_lastline_set
rb_lastline_set_up seems unused?
√ rb_lastline_get

rb_io_gets_m
argf_gets
rb_gets
io_s_foreach
